(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{cPSY:function(e,n,t){"use strict";t.r(n),t.d(n,"_frontmatter",(function(){return c})),t.d(n,"default",(function(){return u}));var a=t("zLVn"),s=(t("q1tI"),t("7ljp")),i=t("R9HO"),o=t("l8Y3"),r=t("7eke"),c={},p={_frontmatter:c},l=i.a;function u(e){var n=e.components,t=Object(a.a)(e,["components"]);return Object(s.b)(l,Object.assign({},p,t,{components:n,mdxType:"MDXLayout"}),Object(s.b)("p",null,"In the previous articles, I described ",Object(s.b)("a",Object.assign({parentName:"p"},{href:"https://www.vdenboer.com/blog/scenario-replays/"}),"how scenario replays improve developer and cross-team workflows"),", and started describing ",Object(s.b)("a",Object.assign({parentName:"p"},{href:"https://www.vdenboer.com/blog/scenario-replays-requirements/"}),"what you need in order to get them in your product"),". From there, a few requirements emerged for the back-end:"),Object(s.b)("ul",null,Object(s.b)("li",{parentName:"ul"},Object(s.b)("strong",{parentName:"li"},"Being able to quickly start the back-end with a clean slate:")," every time we start replaying a scenario, we want an empty database, no authenticated users and have any external services (Mailchip, Getstream.io, etc.) also in a clean state. Performance is important here, because we might be loading many instances of the backend in parallel."),Object(s.b)("li",{parentName:"ul"},Object(s.b)("strong",{parentName:"li"},"Being able to run multiple instances of the backend in parallel:")," if you want to have an overview UI in which you can visually navigate all important workflows in your product, you have to be able to display many instances of your application side by side. A workflow might display a user at a sign-in form and next to it show what the application looks like after a successful sign-in. These two instances of the application should not interfere with each other, neither consume too much resources so it becomes infeasible to run at least 30 parallel instances. The higher the number of possible parallel instances, the better the UX will be when navigating the workflows in the overview UI.")),Object(s.b)("p",null,"In order to achieve this, we’re going to make a few design choices:"),Object(s.b)("ul",null,Object(s.b)("li",{parentName:"ul"},Object(s.b)("strong",{parentName:"li"},"Avoid globals and frameworks that force using them: "),"a lot of frameworks use globals for increased convenience, allowing you to easily execute database operations from anywhere in your application. Aside from that introducing a lot of unwanted complexity in your codebase (do you know what is really going on and can debug it when you need to?), it also prevents isolation between different instances of the program."),Object(s.b)("li",{parentName:"ul"},Object(s.b)("strong",{parentName:"li"},"Make clear boundaries between systems: "),"it should be easy to swap out certain parts of the system with mocks. For example, if you’re using an external service like Mailchimp, you might want to create a simple mock emulating only the functionality you use. Also, if you set things up right, you can check which functionality offered by your database system you actually use, so you can swap it with an in-memory replacement with improved performance during development.")),Object(s.b)("h2",null,"Setting up isolated back-end instances"),Object(s.b)("p",null,"A naive approach to running multiple parallel instances would be to fire up multiple instances of the back-end as separate processes. But, aside from being prohibitively resource hungry, this also gets complicated quickly. Instead, we’ll make a data structure representing a single application instance (with its database connection, auth states, etc.) and choose on a per-request basis which one to use."),Object(s.b)("pre",null,Object(s.b)("code",Object.assign({parentName:"pre"},{className:"language-ts"}),'interface Application {\n  // every instance gets its own ID\n  id: number;\n\n  // could be a connection to an actual (No)SQL database,\n  // or an in-memory mock of a database\n  db: any;\n\n  // every instance has it\'s own sessions,\n  // including things like auth state\n  sessionStore: any;\n}\n\ninterface MetaApplication {\n  applicationCount: number;\n  applications: { [id: number]: Application };\n  defaultApplication: Application;\n}\n\nfunction createAppplication(\n  metaApp: Omit<MetaApplication, "defaultApplication">\n) {\n  const id = metaApp.applicationCount++;\n  const app: Application = {\n    id,\n    db: createDatabaseConnection(),\n    sessionStore: createSessionStore(),\n  };\n  metaApp.applications[id] = app;\n  return app;\n}\n\nfunction createMetaApplication(): MetaApplication {\n  const metaApp: Omit<MetaApplication, "defaultApplication"> = {\n    applicationCount: 0,\n    applications: {},\n  };\n  const defaultApplication = createAppplication(metaApp);\n  return {\n    ...metaApp,\n    defaultApplication,\n  };\n}\n')),Object(s.b)("p",null,"Then, we’ll create an endpoint to create a new application instance and get the ID (example using Express):"),Object(s.b)("pre",null,Object(s.b)("code",Object.assign({parentName:"pre"},{className:"language-ts"}),'if (process.env.NODE_ENV === "development") {\n  expressApp.post("/app/create", (req, res) => {\n    const app = createAppplication(metaApp);\n    // do any initialization of new app here\n    res.send({ appId: app.id });\n  });\n}\n')),Object(s.b)("p",null,"After this, the front-end in development mode is expected to send us the application ID (whether as a header or in the request body.) Using this, we can find the right application instance to work with when handling other requests. If not provided, we’ll just use the default application instance:"),Object(s.b)("pre",null,Object(s.b)("code",Object.assign({parentName:"pre"},{className:"language-ts"}),'// This could be moved to an Express middleware\nfunction getApplication(\n  metaApp: MetaApplication,\n  req: express.Request,\n  res: express.Response\n) {\n  const isDev = process.env.NODE_ENV === "development";\n  const appId = isDev && req.headers["X-Application-ID"];\n  const app = appId ? metaApp.applications[appId] : metaApp.defaultApplication;\n  if (app) {\n    return app;\n  }\n\n  res.status(403);\n  res.send(`App ID not found: ${appId}`);\n  return null;\n}\n\nexpressApp.post("/foo", (req, res) => {\n  const app = getApplication(metaApp, req, res);\n  // do something useful with the app\n});\n')),Object(s.b)("p",null,"That’s what it all boils down to! Now, when you start your front-end, you can create a new application instance before doing any UI actions (either manually or automatically through scenarios.) And, because you can create multiple application instances in parallel, you can display multiple states of the application in the same window."),Object(s.b)("h2",null,"Creating clean data sets"),Object(s.b)("p",null,"The idea is that every application instance has its own database. Every scenario will have its own starting data set and assumptions about what data is stored. Also, the overview UI may be showing entirely different workflows at the same time. How you create these database depends on the specific database you're using."),Object(s.b)("p",null,"Personally, I like to use an abstraction over the database that can either talk to a real database or just store, manipulate and query data straight from memory. One example of this might be using an SQL abstraction layer where you can use either PostgreSQL or an in-memory SQLite connection during development. Or, in case of ",Object(s.b)("a",Object.assign({parentName:"p"},{href:"https://medium.com/worldbrain/storex-a-modular-and-portable-database-abstraction-ecosystem-for-javascript-c38194335c66"}),"Storex")," you have a Mongo-like syntax that can be executed in IndexedDB, SQL databases and Firestore, or it can create an in-memory database."),Object(s.b)("p",null,"If you're using raw SQL, you might create a new schema for each application and drop them when they're not used anymore. Or when you're using Firestore, you may either use the testing library to create new databases, or just create a new top-level collection for each application instance, under which you nest your normal schema."),Object(s.b)("p",null,"Whatever you do, make sure it's fast. Using the Firestore emulator for example, it turned out to be much faster to keep creating new databases, rather than cleaning out all data in the unused ones. In that case, it didn't matter so much, because they aren't persisted to disk anyway."),Object(s.b)("h2",null,"Centralizing requests to the back-end"),Object(s.b)("p",null,"Every request to the back-end now requires an application ID attached to it. It may be that there’s one application ID used throughout the entire lifetime. But, when you’re displaying the overview UI containing many isolated instances of your application side by side, each isolated instance needs to make requests to a different application ID."),Object(s.b)("p",null,"If you want to support the overview UI, you’ll need to pass down a single function or interface to make back-end requests to different parts of your application that remembers the application ID."),Object(s.b)("pre",null,Object(s.b)("code",Object.assign({parentName:"pre"},{className:"language-ts"}),'type BackendRequester = (url: string, init?: RequestInit) => Promise<Response>;\n\nasync function main() {\n  const appCreation = await fetch("/app/create");\n  const { appId } = await appCreation.json();\n  const backendRequest: BackendRequester = (url, init?) => {\n    init = init ?? {};\n    init.headers = init.headers ?? {};\n    init.headers["X-Application-ID"] = appId;\n    return fetch(url, init);\n  };\n\n  runUI({ backendRequest });\n}\n\nasync function runUI(dependencies: { backendRequest: BackendRequester }) {\n  // imagine this function runs your React,\n  // Vue or vanilla JS UI\n  await dependencies.backendRequest("/do/something");\n}\n')),Object(s.b)("p",null,"If you don’t need the overview UI, you can make a single function or interface used by the rest of the UI that uses a global application ID."),Object(s.b)("pre",null,Object(s.b)("code",Object.assign({parentName:"pre"},{className:"language-ts"}),'let globalAppId: number;\nconst backendRequest: BackendRequester = (url, init?) => {\n  init = init ?? {};\n  init.headers = init.headers ?? {};\n  init.headers["X-Application-ID"] = globalAppId;\n  return fetch(url, init);\n};\n\nasync function main() {\n  const appCreation = await fetch("/app/create");\n  const { appId } = await appCreation.json();\n  globalAppId = appId;\n\n  runUI();\n}\n\nasync function runUI() {\n  await backendRequest("/do/something");\n}\n')),Object(s.b)("p",null,"The trade-off here is that passing down a function or instance to every place that needs it can get messy quickly if you aren’t careful. Using a single function or instance throughout the application that you can use directly might be easier to adopt, while still getting the advantage of scenario replays and increased debuggability (since you can now inspect and modify requests in a single place.)"),Object(s.b)("h2",null,"Isolating sessions & authentication state"),Object(s.b)("p",null,"Often, session IDs are stored in (encrypted) cookies, which are then used in the backend to get per-user state, such as which user is currently authenticated. In the overview UI we might display states side by side where different users might be authenticated. So we should be able to send different requests with different session IDs."),Object(s.b)("p",null,"The most elegant solution here is to transmit the session IDs through headers instead of cookies in development mode. This way, every UI state can remember its session ID and send it with each individual request instead of it being ‘global state’ as it is with cookies."),Object(s.b)("p",null,"This can be done by modifying the above function passed into the UI to remember a session ID:"),Object(s.b)("pre",null,Object(s.b)("code",Object.assign({parentName:"pre"},{className:"language-ts"}),'let sessionId: string;\nconst backendRequest: BackendRequester = async (url, init?) => {\n  init = init ?? {};\n  init.headers = init.headers ?? {};\n  init.headers["X-Application-ID"] = appId;\n  if (sessionId) {\n    init.headers["X-Session-ID"] = sessionId;\n  }\n  const response = await fetch(url, init);\n  const newSessionId = response.headers["X-Session-ID"];\n  if (newSessionId) {\n    sessionId = newSessionId;\n  }\n  return response;\n};\n')),Object(s.b)("p",null,"In the back-end, we can use this to create and retrieve the session:"),Object(s.b)("pre",null,Object(s.b)("code",Object.assign({parentName:"pre"},{className:"language-ts"}),'expressApp.post("/login", (req, res) => {\n  const app = getApplication(metaApp, req, res);\n  const userId = authenticate(app.db, req.body.email, req.body.password);\n  const sessionId = app.sessionStore.createSession({ userId });\n  res.headers["X-Session-ID"] = sessionId;\n  res.send("OK");\n});\n\nexpressApp.post("/foo", (req, res) => {\n  const app = getApplication(metaApp, req, res);\n  const sessionId = req.headers["X-Session-ID"];\n  const session = app.sessionStore.getSession(sessionId);\n  if (session.userId) {\n    // do something\n  }\n});\n')),Object(s.b)("h2",null,"What’s next?"),Object(s.b)("p",null,"I’ll dive into the most interesting aspects of implementing scenario replays in your product in the ",Object(s.b)("em",{parentName:"p"},"scenario replays and cross-team collaboration")," series. If you want to receive articles as they come out, you can ",Object(s.b)(o.a,{mdxType:"NewsletterLink"},"subscribe to the series by joining the mailing list"),"."),Object(s.b)(r.a,{current:"/blog/rapid-iteration-backend",mdxType:"ScenarioReplaysFollowUps"}))}u.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-pages-blog-rapid-iteration-backend-mdx-f0ac864c82dcdeb39229.js.map